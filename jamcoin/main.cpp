#include <iostream>
#include <cstdint>
#include <string>
#include <algorithm>


// Taken from : https://bitbucket.org/genbattle/projecteuler/src/01d182703fba9457a576cff5f4bda6bfa3e68823/C++/Common/prime.hpp
/*
This header defines some basic Prime-finding methods that gets re-used fairly
often for Project Euler problems.
*/
#include <vector>
#include <cmath>

// Checks if a number is prime using a sort-of prime sieve
template<typename T>
T is_prime_sieve(T num) {
    // Stores primes generated by the sieve for subsequent calls
    static std::vector<T> primes = { 2, 3 };
    if (num < 2)
        return num;
    else if (num < 4)
        return num;
    // generate primes up to sqrt(num) if they are not already available
    T max = sqrt(num);
    {
        T next = primes[primes.size() - 1] + 1;
        while (next <= max) {
            while (![&]() -> bool {
                for (const T& i: primes) {
                    if (i > max)
                        return true;
                    if (next % i == 0 && next != i)
                        return false;
                }
                return true;
            }()) {
                ++next;
            }
            // add newly discovered prime to the list
            primes.push_back(next);
            ++next;
        }
    }
    for (const T& i: primes) {
        if (i > max)
            return num;
        if (num % i == 0)
            return i;
    }
    return num;
}

uint64_t to_base(uint64_t binary_digits, int base)
{
    uint64_t num = 0;
    for (uint64_t value = 1; binary_digits; binary_digits >>= 1)
    {
        num += ( binary_digits & 1 ) ? value : 0;
        value *= base;
    }
    
    return num;
}

uint64_t make_jamcoin(uint64_t inner_digits, int length)
{
    uint64_t mask = ((1 << (length - 3)) - 1) << 1;
    return (1 << (length - 1)) | ((inner_digits << 1) & mask) | 1;
}

std::string to_string(uint64_t jamcoin, int length)
{
    std::string rv;
    
    for (unsigned mask = (1 << (length - 1)); mask > 0; mask >>=1)
    {
        rv += '0' + !!(mask & jamcoin);
    }
    
    return rv;
}

int main()
{
    int number_of_inputs = 0;

    std::cin >> number_of_inputs;

    int count, length;
    for (int i = 0; i < number_of_inputs; ++i)
    {
        std::cin >> length >> count;

        std::cout << "Case #" << (i + 1) << ":" << std::endl;

        if (length > 62)
        {
            std::cout << "ERROR! You didn't account for this" << std::endl;
            return 1;
        }
        
        uint64_t inner_digits = 0;
        for (int j = 0; j < count;)
        {
            uint64_t candidate;
            bool is_jamcoin = false;
            std::vector<uint64_t> divisors;
            for (; !is_jamcoin; ++inner_digits)
            {
                candidate = make_jamcoin(inner_digits, length);
                std::cout << "Testing jamcoin: " << to_string(candidate, length) << std::endl;
                is_jamcoin = true;
                for (int k = 2; k <= 10; ++k)
                {
                    uint64_t num = to_base(candidate, k);
                    std::cout << "Testing in base " << k << " number " << num << std::endl;
                    uint64_t divisor = is_prime_sieve<uint64_t>(num);
                    if (divisor == num)
                    {
                        is_jamcoin = false;
                        std::cout << " failed. " << divisor << " is prime in base " << k << std::endl;
                        break;
                    }
                    divisors.push_back(divisor);
                }
            }
            
            if (is_jamcoin)
            {
                std::cout << to_string(candidate, length);
                for (auto d : divisors)
                {
                    std::cout << " " << d;
                }
                std::cout << std::endl;
                ++j;
            }
        }
        std::cout << std::endl;
    }

    return 0;
}



#include <iostream>
#include <cstdint>
#include <string>
#include <algorithm>


// Taken from : https://bitbucket.org/genbattle/projecteuler/src/01d182703fba9457a576cff5f4bda6bfa3e68823/C++/Common/prime.hpp
/*
This header defines some basic Prime-finding methods that gets re-used fairly
often for Project Euler problems.
*/
#include <vector>
#include <cmath>
#include <boost/multiprecision/cpp_int.hpp>

namespace mp = boost::multiprecision;

// Checks if a number is prime using a sort-of prime sieve
template<typename T>
T is_prime_sieve(T num, T limit) {
    // Stores primes generated by the sieve for subsequent calls
    static std::vector<T> primes = { 2, 3 };
    if (num < 2)
        return num;
    else if (num < 4)
        return num;
    // generate primes up to sqrt(num) if they are not already available
    T max = sqrt(num);
    {
        T next = primes[primes.size() - 1] + 1;
        while (next <= max && next <= limit) {
            while (![&]() -> bool {
                for (const T& i: primes) {
                    if (i > max)
                        return true;
                    if (next % i == 0 && next != i)
                        return false;
                }
                return true;
            }()) {
                ++next;
            }
            // add newly discovered prime to the list
            primes.push_back(next);
            ++next;
        }
    }
    for (const T& i: primes) {
        if (i > max || i > limit)
            return num;
        if (num % i == 0)
            return i;
    }
    return num;
}

mp::uint128_t to_base(mp::uint128_t binary_digits, int base)
{
    mp::uint128_t num = 0;
    for (mp::uint128_t value = 1; binary_digits; binary_digits >>= 1)
    {
        num += ( binary_digits & 1 ) ? value : 0;
        value *= base;
    }
    
    return num;
}

mp::uint128_t make_jamcoin(mp::uint128_t inner_digits, int length)
{
    mp::uint128_t mask = ((1 << (length - 3)) - 1) << 1;
    return (1 << (length - 1)) | ((inner_digits << 1) & mask) | 1;
}

std::string to_string(mp::uint128_t jamcoin, int length)
{
    std::string rv;
    
    for (mp::uint128_t mask = (1 << (length - 1)); mask > 0; mask >>=1)
    {
        rv += '0' + !!(mask & jamcoin);
    }
    
    return rv;
}

int main()
{
    int number_of_inputs = 0;

    std::cin >> number_of_inputs;

    int count, length;
    for (int i = 0; i < number_of_inputs; ++i)
    {
        std::cin >> length >> count;

        std::cout << "Case #" << (i + 1) << ":" << std::endl;

        if (length > 62)
        {
            std::cout << "ERROR! You didn't account for this" << std::endl;
            return 1;
        }
        
        mp::uint128_t sieve_limit = 1000;
        mp::uint128_t inner_digits = 0;
        std::vector<mp::uint128_t> printed_inner_digits;
        for (int j = 0; j < count;)
        {
            mp::uint128_t candidate;
            bool is_jamcoin = false;
            std::vector<mp::uint128_t> divisors;
            for (; !is_jamcoin; ++inner_digits)
            {
                if (std::find(printed_inner_digits.begin(), printed_inner_digits.end(), inner_digits) != printed_inner_digits.end())
                {
                    continue; // Already printed...
                }
                candidate = make_jamcoin(inner_digits, length);
                is_jamcoin = true;
                divisors.clear();
                for (int k = 2; k <= 10; ++k)
                {
                    mp::uint128_t num = to_base(candidate, k);
                    mp::uint128_t divisor = is_prime_sieve<mp::uint128_t>(num, sieve_limit);
                    if (divisor == num)
                    {
                        is_jamcoin = false;
                        break;
                    }
                    divisors.push_back(divisor);
                }
            }
            
            if (is_jamcoin)
            {
                std::cout << to_string(candidate, length);
                for (auto d : divisors)
                {
                    std::cout << " " << d;
                }
                std::cout << std::endl;
                ++j;
                printed_inner_digits.push_back(inner_digits);
            }

            if (inner_digits == ((1 << (length - 3)) - 1))
            {
                inner_digits = 0;
                sieve_limit *= 2;
            }
        }
    }

    return 0;
}


